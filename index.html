<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‡´æˆ‘æœ€çˆ±çš„ä½  â¤ï¸</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "PingFang SC", "Microsoft YaHei", sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; touch-action: none; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ff69b4;
            transition: opacity 1s;
        }
        #start-btn {
            display: none; padding: 12px 30px; background: #ff69b4; color: white;
            border: none; border-radius: 25px; font-size: 16px; font-weight: bold;
            box-shadow: 0 0 15px rgba(255,105,180,0.5);
        }
    </style>
</head>
<body>

<div id="overlay">
    <div style="font-size:40px; margin-bottom: 15px;">ğŸ’–</div>
    <div id="status">æ­£åœ¨è½»é‡åŒ–åŠ è½½æµªæ¼«...</div>
    <button id="start-btn">å¼€å¯æ—¶åˆ»</button>
</div>

<div id="container"></div>
<audio id="bgm" loop src="love.mp3"></audio>
<canvas id="textCanvas" style="display:none;"></canvas>

<script src="https://lib.baomitu.com/three.js/r128/three.min.js"></script>

<script>
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const PHOTO_COUNT = 30;
    const PARTICLE_COUNT = isMobile ? 10000 : 15000; // æ‰‹æœºç«¯å‡å°‘ç²’å­

    let scene, camera, renderer, starPoints, photoMeshes = [];
    let loadProgress = 0, isTouching = false;
    let tX = 0, tY = 0, dragStartX = 0, dragStartY = 0, dragOffsetX = 0, dragOffsetY = 0;

    let heartPositions = [], textOptionsPositions = [];
    let particleAttributes = [], photoRandoms = [];
    let currentTextIndex = 0;

    const loveWords = [
        "æˆ‘åªçˆ±ç”°ç”œ", "æˆ‘å¥½æƒ³ä½ ", "å†¯æ³ è¶Šä¸çæƒœç”°ç”œå¤©æ‰“é›·åŠˆ",
        "å°å®å®è¦é…å°åŒ…åŒ…", "æˆ‘è¦ç»™ä½ æ´—ä¸€è¾ˆå­è„š", "lvå’Œloveæˆ‘éƒ½è¦ç»™ä½ ",
        "ä½ æŠŠæˆ‘ç…§é¡¾çš„å¾ˆå¥½å®å®", "è°¢è°¢ä½ çš„å‡ºç°", "æˆ‘çˆ±ä½ ",
        "ä¼šæœ‰å«lpçš„é‚£ä¸€å¤©çš„", "å®å®æƒ…äººèŠ‚å¿«ä¹", "ä½ æ¯”æ‰€æœ‰å°çŒ«éƒ½å¯çˆ±",
        "ä»Šå¹´å¼ºåº¦ä¸€èˆ¬ï¼Œæ˜å¹´å†æ¥å†å‰"
    ];

    function createTextPositions(text) {
        const canvas = document.getElementById('textCanvas');
        const ctx = canvas.getContext('2d');

        // æ‰‹æœºç«¯å¤§å¹…å‡å°å†…å­˜å ç”¨
        canvas.width = isMobile ? 1200 : 2000;
        canvas.height = isMobile ? 600 : 1000;

        const fontSize = text.length > 8 ? (isMobile ? 70 : 110) : (isMobile ? 110 : 180);
        const spread = text.length > 8 ? (isMobile ? 35 : 55) : (isMobile ? 28 : 42);

        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${fontSize}px "PingFang SC", "Microsoft YaHei", sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const points = [];
        const skip = isMobile ? 4 : 2; // æ‰‹æœºç«¯è·³è¿‡æ›´å¤šåƒç´ ä»¥èŠ‚çœå†…å­˜

        for(let y = 0; y < canvas.height; y += skip) {
            for(let x = 0; x < canvas.width; x += skip) {
                if(data[(y * canvas.width + x) * 4] > 128) {
                    points.push({
                        x: (x - canvas.width/2) / spread,
                        y: -(y - canvas.height/2) / spread,
                        z: 0
                    });
                }
            }
        }
        return points;
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true }); // æ‰‹æœºç«¯å…³é—­æŠ—é”¯é½¿æå‡æ€§èƒ½
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        // ç”Ÿæˆå¿ƒå½¢
        let count = 0;
        while (count < PARTICLE_COUNT) {
            const x = (Math.random() - 0.5) * 3, y = (Math.random() - 0.5) * 3, z = (Math.random() - 0.5) * 3;
            const a = x * x + (9 / 4) * y * y + z * z - 1;
            if (a * a * a - x * x * z * z * z - (9 / 80) * y * y * z * z * z < 0) {
                heartPositions.push({ x: x * 8.5, y: z * 8.5 + 2, z: y * 8.5 });
                particleAttributes.push({ phi: Math.random() * Math.PI * 2, spd: 1 + Math.random() * 2 });
                count++;
            }
        }

        loveWords.forEach(word => textOptionsPositions.push(createTextPositions(word)));

        const geo = new THREE.BufferGeometry();
        const posArr = new Float32Array(PARTICLE_COUNT * 3);
        for(let i = 0; i < PARTICLE_COUNT; i++) {
            posArr[i*3] = heartPositions[i].x; posArr[i*3+1] = heartPositions[i].y; posArr[i*3+2] = heartPositions[i].z;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));

        starPoints = new THREE.Points(geo, new THREE.PointsMaterial({
            color: 0xff69b4, size: isMobile ? 0.22 : 0.12, // æ‰‹æœºç«¯è°ƒå¤§ç²’å­ä»¥è¦†ç›–ç©ºéš™
            transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        scene.add(starPoints);

        // é™åˆ¶ç…§ç‰‡è´¨é‡æˆ–æ•°é‡ï¼ˆå¯é€‰ï¼Œè¿™é‡Œç»´æŒ 30 å¼ ï¼Œä½†å¢åŠ æŠ¥é”™å¤„ç†ï¼‰
        const loader = new THREE.TextureLoader();
        for (let i = 1; i <= PHOTO_COUNT; i++) {
            photoRandoms.push({ phi: Math.random() * Math.PI * 2, radius: 10 + Math.random() * 8, yR: (Math.random() - 0.5) * 15, zR: (Math.random() - 0.5) * 10, spd: 0.3 + Math.random() * 0.4 });
            loader.load(`pics/${i}.jpg`, (tex) => {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.3, 3.1), new THREE.MeshBasicMaterial({map: tex, transparent: true, opacity: 0, side: THREE.DoubleSide}));
                mesh.scale.set(0.01, 0.01, 0.01); scene.add(mesh); photoMeshes.push(mesh);
                checkProgress();
            }, undefined, checkProgress);
        }
        function checkProgress() {
            if (++loadProgress >= PHOTO_COUNT) document.getElementById('start-btn').style.display = 'block';
        }

        const container = document.getElementById('container');
        const get3DPos = (e) => {
            const ev = e.touches ? e.touches[0] : e;
            return { x: (ev.clientX / window.innerWidth) * 44 - 22, y: -(ev.clientY / window.innerHeight) * 34 + 17 };
        };
        const start = (e) => {
            isTouching = true; currentTextIndex = Math.floor(Math.random() * loveWords.length);
            const pos = get3DPos(e); dragStartX = pos.x; dragStartY = pos.y; tX = pos.x; tY = pos.y;
        };
        const move = (e) => { if(isTouching) { const pos = get3DPos(e); dragOffsetX = pos.x - dragStartX; dragOffsetY = pos.y - dragStartY; tX = pos.x; tY = pos.y; } };
        container.addEventListener('pointerdown', start);
        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', () => isTouching = false);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = starPoints.geometry.attributes.position.array;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const attr = particleAttributes[i];
            let tx, ty, tz;

            if (isTouching) {
                const targetArr = textOptionsPositions[currentTextIndex];
                const target = targetArr[i % targetArr.length];
                tx = target.x + dragOffsetX; ty = target.y + dragOffsetY; tz = target.z;
            } else {
                const target = heartPositions[i];
                tx = target.x + Math.sin(time * 2 + attr.phi) * 0.15; ty = target.y + Math.cos(time * 2 + attr.phi) * 0.15; tz = target.z;
            }
            positions[i3] += (tx - positions[i3]) * 0.1;
            positions[i3+1] += (ty - positions[i3+1]) * 0.1;
            positions[i3+2] += (tz - positions[i3+2]) * 0.1;
        }
        starPoints.geometry.attributes.position.needsUpdate = true;
        if (!isTouching) starPoints.rotation.y += 0.006;

        photoMeshes.forEach((mesh, i) => {
            if (isTouching) {
                const r = photoRandoms[i]; const angle = time * r.spd + r.phi;
                mesh.position.lerp(new THREE.Vector3(tX+Math.cos(angle)*r.radius, tY+Math.sin(angle)*r.radius, r.zR), 0.05);
                mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.05);
                mesh.material.opacity += (0.8 - mesh.material.opacity) * 0.05;
                mesh.lookAt(camera.position);
            } else {
                mesh.material.opacity *= 0.8; mesh.scale.set(0.01, 0.01, 0.01);
            }
        });
        renderer.render(scene, camera);
    }

    document.getElementById('start-btn').onclick = () => {
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 1000);
        document.getElementById('bgm').play().catch(()=>{});
    };
    init(); animate();
</script>
</body>
</html>